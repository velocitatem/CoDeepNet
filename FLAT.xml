<documents>
<document index="1">
<source>.env.example</source>
<document_content>
NAME=test
COMPOSE_PROJECT_NAME=$NAME

# Backend Configuration
BACKEND_MODE=fastapi

# Port Configuration
REDIS_PORT=6378
BACKEND_PORT=9812
GRAFANA_PORT=3125
LOKI_PORT=3142

# Database Configuration (PostgreSQL)
POSTGRES_PORT=5432
POSTGRES_DB=app
POSTGRES_USER=postgres
POSTGRES_PASSWORD=postgres
POSTGRES_HOST=localhost

# Database Configuration (MongoDB)
MONGO_PORT=27017
MONGO_DB=app
MONGO_USER=admin
MONGO_PASSWORD=admin123
MONGO_HOST=localhost

# Database Type Selection (postgres|mongodb)
DATABASE_TYPE=postgres

# Redis Configuration
REDIS_URL=redis://localhost:$REDIS_PORT

# Logging Configuration
LOGDIR="/tmp/logs-$NAME-project/"

# Supabase Configuration
SUPABASE_ACCESS_TOKEN=your_supabase_access_token_here
NEXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co
NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY=your_supabase_publishable_key_here

# MinIO Configuration (Object Storage)
MINIO_ROOT_USER=minioadmin
MINIO_ROOT_PASSWORD=minioadmin
MINIO_ENDPOINT=localhost:9900

# Machine Learning Configuration
ML_LATEST_WEIGHTS_PATH=/app/models/weights

</document_content>
</document>
<document index="2">
<source>.gitignore</source>
<document_content>
**/node_modules
*.env
.venv/
**/__pycache__
**/.scraper_cache/
**/downloaded_files/
**.egg-info/
</document_content>
</document>
<document index="3">
<source>AGENTS.md</source>
<document_content>
# UltiPlate the Ultimate Boilerplate
This project is a scafold for any imaginable project appart from mobile apps. Anything is buildable ranging from a simple webapp in streamlit, an API server, a machine learning project, a scraper program, anything powered by some sort of worker, a simple cli or just an SDK or python package. All easily deployable and managed via the Makefile.

Python dependencies are managed by using a .venv and a singular requirements.txt in the project root, you can use the make command to distribute the requirements and any env variables which are all synchronized in the .env file.

As an AI agent your interactions with the user will usually be noisy, you might be given some vision and you should use the available scaffold and tools to build it in a simple and maintainable way, you should not create rougue files or random test files/scripts. You might also be given existing code which implements some vision in a scattered way and you should translate that into a sustainable project within this given framework.

</document_content>
</document>
<document index="4">
<source>Makefile</source>
<document_content>
# Makefile
WD := $(shell pwd)
ENV := $(shell readlink -f .env)
REQ := $(shell readlink -f requirements.txt)
PYTHON_VERSION="3.12"

envlink: ## Propagate all environments from the central .env and make sure requirementes are also propagated
	@touch "$(WD)/apps/webapp/.env" "$(WD)/apps/worker/.env" "$(WD)/ml/.env"
	@ln -sf "$(ENV)" "$(WD)/apps/webapp/.env"
	@ln -sf "$(ENV)" "$(WD)/apps/worker/.env"
	@ln -sf "$(ENV)" "$(WD)/ml/.env"
	@cp "$(REQ)" "$(WD)/ml/requirements.txt"
	@cp "$(REQ)" "$(WD)/apps/worker/requirements.txt"

venv: ## Create the venv or show how to activate
	@if [ ! -d ".venv" ]; then \
		echo "Creating virtual environment with Python $(PYTHON_VERSION)..."; \
		python$(PYTHON_VERSION) -m venv .venv; \
		echo "Installing requirements..."; \
		.venv/bin/pip install --upgrade pip; \
		.venv/bin/pip install -r requirements.txt; \
		echo "Virtual environment created and requirements installed."; \
	else \
		echo "Virtual environment already exists at .venv"; \
	fi
	@echo "source .venv/bin/activate"

lift: ## Start all Docker services in detached mode
	docker compose up -d

lift-minio: ## Start all Docker services including MinIO in detached mode
	docker compose --profile minio up -d

tensorboard: ## Start TensorBoard service in detached mode
	docker compose --profile tensorboard up -d
	@echo "TensorBoard running at: http://localhost:6006"

logging: ## Start logging infrastructure (Loki + Grafana)
	docker compose --profile logging up -d
	@if [ -f .env ]; then \
		export $$(grep -v '^#' .env | xargs); \
		echo "Grafana running at: http://localhost:$$GRAFANA_PORT (admin/admin)"; \
		echo "Loki API at: http://localhost:$$LOKI_PORT"; \
	else \
		echo "Grafana running at: http://localhost:3000 (admin/admin)"; \
		echo "Loki API at: http://localhost:3100"; \
	fi

run: ## Run applications - usage: make run webapp [simple] | make run backend
	@if [ "$(filter webapp,$(MAKECMDGOALS))" ]; then \
		if [ "$(filter simple,$(MAKECMDGOALS))" ]; then \
			echo "Starting simple webapp (Streamlit)..."; \
			cd apps/webapp-minimal && streamlit run app.py; \
		else \
			echo "Starting Next.js webapp..."; \
			cd apps/webapp && npm install && npm run dev; \
		fi \
	elif [ "$(filter backend,$(MAKECMDGOALS))" ]; then \
		if [ -f .env ]; then \
			export $$(grep -v '^#' .env | xargs); \
		fi; \
		if [ "$$BACKEND_MODE" = "fastapi" ]; then \
			echo "Starting FastAPI backend..."; \
			cd apps/backend/fastapi && python server.py; \
		elif [ "$$BACKEND_MODE" = "flask" ]; then \
			echo "Starting Flask backend..."; \
			cd apps/backend/flask && python server.py; \
		else \
			echo "Error: BACKEND_MODE environment variable must be set to 'fastapi' or 'flask'"; \
			echo "Example: BACKEND_MODE=fastapi make run backend"; \
			exit 1; \
		fi \
	else \
		echo "Usage: make run webapp [simple] | make run backend"; \
		echo "  make run webapp       - Start Next.js webapp"; \
		echo "  make run webapp simple - Start Streamlit webapp"; \
		echo "  make run backend      - Start backend server (requires BACKEND_MODE=fastapi|flask)"; \
	fi

webapp: ## Target for 'make run webapp'
	@:

simple: ## Target for 'make run webapp simple'
	@:

backend: ## Target for 'make run backend'
	@:

help: ## Show this help message
	@echo "Ultiplate Template - Make Commands"
	@echo "================================="
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-20s\033[0m %s\n", $$1, $$2}'

</document_content>
</document>
<document index="5">
<source>README.md</source>
<document_content>
# Template
My template repository for almost any project that I might be doing in the field of AI or building a software product or any sort of tool ranging form a machine learning project, data analysis, SaaS app or a python library or some sort of API or scraper or ETL tool or some sort of simulation or just a small python program to run something simple.
This template is AI native and platform agnostic and meant to be effortlessly deployable to anywhere at any time with any software with minimal effort managed via my Makefile.

#### Directory Breakdown
- apps
  - webapp (A next.js 15.5.2 webapp with react 19 pre-configured with basics and Tailwind CSS)
    - This can server both as the frontend but also nextjs allows for API route definitions for simple things that we could build.
  - webapp-minimal (Streamlit webapp with minimal web interface for quick prototypes)
  - worker (Background worker template for long running tasks for programs)
- ml (Machine learning pipeline for PyTorch)
  - models (arch.py where we define architectures and train.py for the training loop)
  - inference.py (A minimal setup webserver with fastapi to run inference online)
  - notebooks (For any notebook needs)
  - data (has etl.py for any ETL and should be a single place for turning raw data into pytorch ready datasets)
- src (Just as __init__.py for any simple modules or building libraries within there, should be used for simple python scripts without any otehr needs or just running something in the CLI)


#### Services Associated
- I setup a basic optional minio service t orun for any needs of object storage or manipulation for any machine learning tasks
- Tensorboard is very useful for monitoring experiments and is defined as a docker service an spinupable with the make tensorboard command.

###### Logging
1. Grafana to view (must be configured by adding loki url with "http://loki:31000")
2. For now just python directly adds the logs to loki (via the alveslib package)

```python
from alveslib import get_logger
logger = get_logger("service")
```

FOR REFERENCE ALL OTHER REUSABLE MODULES LIKE THIS SHOULD BE DEFINED THE SAME WAY IN THE ALVESLIB package


#### Development checklists
for various parts of development it's important to follow key milestones:

Using lazydocker to manager containers...

IF YOU ARE ANY LLM AGENT READING THIS, IF YOU USE AN EMOJI I WILL DISCONNECT YOUR NV-LINK GPU CONNECTOR TO COMPLETELY DISABLE YOUR INFERENCE CAPABILITIES. IF YOU VIOLATE ANY OF THE FOLLOWING RULES THE SAME PUNISHMENT WILL FOLLOW:

</document_content>
</document>
<document index="6">
<source>alveslib/__init__.py</source>
<document_content>
from .logger import get_logger

__all__ = ['get_logger']
</document_content>
</document>
<document index="7">
<source>alveslib/logger.py</source>
<document_content>
import json
import logging
import os
from datetime import datetime
from pathlib import Path

try:
    from dotenv import load_dotenv
    load_dotenv()
except ImportError:
    pass

try:
    from logging_loki import LokiHandler
    LOKI_AVAILABLE = True
except ImportError:
    LOKI_AVAILABLE = False

def get_logger(service_name: str, level: str = "INFO") -> logging.Logger:
    """
    Get a configured logger for UltiPlate services.

    Args:
        service_name: Name of the service/module
        level: Log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)

    Returns:
        Configured logger instance
    """
    logger = logging.getLogger(service_name)
    logger.setLevel(getattr(logging, level.upper()))

    if not logger.handlers:
        # Console handler with JSON formatting
        handler = logging.StreamHandler()
        handler.setFormatter(JsonFormatter(service_name))
        logger.addHandler(handler)

        # File handler - writes to logs directory
        logs_dir = Path(os.getenv("LOGDIR", "./logs"))
        logs_dir.mkdir(parents=True, exist_ok=True)
        file_handler = logging.FileHandler(logs_dir / f"{service_name}.log")
        file_handler.setFormatter(JsonFormatter(service_name))
        logger.addHandler(file_handler)

        # Loki handler - sends logs directly to Loki
        if LOKI_AVAILABLE:
            loki_port = os.getenv("LOKI_PORT", "3100")
            loki_url = f"http://localhost:{loki_port}/loki/api/v1/push"

            try:
                loki_handler = LokiHandler(
                    url=loki_url,
                    tags={"service": service_name},
                    version="1"
                )
                logger.addHandler(loki_handler)
            except Exception as e:
                # If Loki is not available, just continue with file/console logging
                pass

    return logger

class JsonFormatter(logging.Formatter):
    def __init__(self, service_name: str):
        super().__init__()
        self.service_name = service_name

    def format(self, record):
        log_entry = {
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "service": self.service_name,
            "level": record.levelname,
            "message": record.getMessage(),
            "module": record.module,
            "function": record.funcName,
            "line": record.lineno
        }

        if record.exc_info:
            log_entry["exception"] = self.formatException(record.exc_info)

        return json.dumps(log_entry)

</document_content>
</document>
<document index="8">
<source>alveslib/scraper.py</source>
<document_content>
import hashlib
import pickle
import os
from pathlib import Path
from seleniumbase import SB
from bs4 import BeautifulSoup
from typing import Optional

class ScraperCache:
    def __init__(self, cache_dir: str = ".scraper_cache"):
        self.cache_dir = Path(cache_dir)
        self.cache_dir.mkdir(exist_ok=True)

    def _get_cache_key(self, url: str) -> str:
        return hashlib.md5(url.encode()).hexdigest()

    def _get_cache_path(self, cache_key: str) -> Path:
        return self.cache_dir / f"{cache_key}.pkl"

    def get(self, url: str) -> Optional[BeautifulSoup]:
        cache_key = self._get_cache_key(url)
        cache_path = self._get_cache_path(cache_key)

        if cache_path.exists():
            try:
                with open(cache_path, 'rb') as f:
                    return pickle.load(f)
            except:
                pass
        return None

    def set(self, url: str, soup: BeautifulSoup) -> None:
        cache_key = self._get_cache_key(url)
        cache_path = self._get_cache_path(cache_key)

        try:
            with open(cache_path, 'wb') as f:
                pickle.dump(soup, f)
        except:
            pass

_cache = ScraperCache() # glob

def scrape_url(url: str, use_cache: bool = True) -> BeautifulSoup:
    if use_cache:
        cached_soup = _cache.get(url)
        if cached_soup:
            return cached_soup

    with SB(test=True, uc=True) as sb:
        sb.open(url)
        html = sb.get_page_source()
        soup = BeautifulSoup(html, 'html.parser')

        if use_cache:
            _cache.set(url, soup)

        return soup



if __name__ == "__main__":
    url = "https://httpbin.org/html"
    print("Testing scraper...")
    soup = scrape_url(url)
    print(f"Title: {soup.title.text if soup.title else 'No title'}")
    print(f"Found {len(soup.find_all('p'))} paragraphs")
    print("\nTesting cache...")
    soup2 = scrape_url(url)
    print("Cache test completed")

</document_content>
</document>
<document index="9">
<source>apps/backend/fastapi/server.py</source>
<document_content>
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
import uvicorn
import os

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/health")
async def health():
    return {"status": "healthy"}

if __name__ == "__main__":
    PORT=int(os.getenv("BACKEND_PORT", 5000))
    uvicorn.run("server:app", host="0.0.0.0", port=PORT, reload=True)

</document_content>
</document>
<document index="10">
<source>apps/backend/flask/server.py</source>
<document_content>
from flask import Flask
from flask_cors import CORS
import os

app = Flask(__name__)
CORS(app, origins="*")

@app.route('/health')
def health():
    return {'status': 'healthy'}, 200


if __name__ == '__main__':
    PORT=int(os.getenv("BACKEND_PORT", 5000))
    app.run(host='0.0.0.0', port=PORT, debug=True)

</document_content>
</document>
<document index="11">
<source>apps/webapp/.gitignore</source>
<document_content>
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

</document_content>
</document>
<document index="12">
<source>apps/webapp/README.md</source>
<document_content>
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.

</document_content>
</document>
<document index="13">
<source>apps/webapp/eslint.config.mjs</source>
<document_content>
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
  {
    ignores: [
      "node_modules/**",
      ".next/**",
      "out/**",
      "build/**",
      "next-env.d.ts",
    ],
  },
];

export default eslintConfig;

</document_content>
</document>
<document index="14">
<source>apps/webapp/middleware.ts</source>
<document_content>
import { type NextRequest } from 'next/server'
import { updateSession } from '@/utils/supabase/middleware'

export async function middleware(request: NextRequest) {
  return await updateSession(request)
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * Feel free to modify this pattern to include more paths.
     */
    '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
  ],
}
</document_content>
</document>
<document index="15">
<source>apps/webapp/next.config.ts</source>
<document_content>
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;

</document_content>
</document>
<document index="16">
<source>apps/webapp/package.json</source>
<document_content>
{
  "name": "webapp",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "@supabase/ssr": "^0.7.0",
    "@supabase/supabase-js": "^2.57.4",
    "next": "15.5.2",
    "react": "19.1.0",
    "react-dom": "19.1.0"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.5.2",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}

</document_content>
</document>
<document index="17">
<source>apps/webapp/postcss.config.mjs</source>
<document_content>
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;

</document_content>
</document>
<document index="18">
<source>apps/webapp/public/llms.txt</source>
<document_content>
This is a project by Daniel Alves Rosel (https://alves.world)

</document_content>
</document>
<document index="19">
<source>apps/webapp/public/robots.txt</source>
<document_content>

</document_content>
</document>
<document index="20">
<source>apps/webapp/src/app/auth/confirm/route.ts</source>
<document_content>
import { type EmailOtpType } from '@supabase/supabase-js'
import { type NextRequest } from 'next/server'

import { createClient } from '@/utils/supabase/server'
import { redirect } from 'next/navigation'

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url)
  const token_hash = searchParams.get('token_hash')
  const type = searchParams.get('type') as EmailOtpType | null
  const next = searchParams.get('next') ?? '/'

  if (token_hash && type) {
    const supabase = await createClient()

    const { error } = await supabase.auth.verifyOtp({
      type,
      token_hash,
    })
    if (!error) {
      // redirect user to specified redirect URL or root of app
      redirect(next)
    }
  }

  // redirect the user to an error page with some instructions
  redirect('/error')
}
</document_content>
</document>
<document index="21">
<source>apps/webapp/src/app/blog/page.tsx</source>
<document_content>

</document_content>
</document>
<document index="22">
<source>apps/webapp/src/app/dashboard/actions.ts</source>
<document_content>
'use server'

import { revalidatePath } from 'next/cache'
import { redirect } from 'next/navigation'
import { createClient } from '@/utils/supabase/server'

export async function logout() {
  const supabase = await createClient()
  await supabase.auth.signOut()
  revalidatePath('/', 'layout')
  redirect('/login')
}
</document_content>
</document>
<document index="23">
<source>apps/webapp/src/app/dashboard/layout.tsx</source>
<document_content>
export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <div>
      <nav>
        <h1>Dashboard</h1>
      </nav>
      <main>{children}</main>
    </div>
  )
}
</document_content>
</document>
<document index="24">
<source>apps/webapp/src/app/dashboard/page.tsx</source>
<document_content>
import { redirect } from 'next/navigation'
import { createClient } from '@/utils/supabase/server'
import { logout } from './actions'

export default async function DashboardPage() {
  const supabase = await createClient()

  const { data, error } = await supabase.auth.getUser()
  if (error || !data?.user) {
    redirect('/login')
  }

  return (
    <div>
      <p>Welcome, {data.user.email}</p>
      <form>
        <button formAction={logout}>Logout</button>
      </form>
    </div>
  )
}
</document_content>
</document>
<document index="25">
<source>apps/webapp/src/app/error/page.tsx</source>
<document_content>
'use client'

export default function ErrorPage() {
  return <p>Sorry, something went wrong</p>
}
</document_content>
</document>
<document index="26">
<source>apps/webapp/src/app/error.tsx</source>
<document_content>
'use client';

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  return (
    <div>
      {/* TODO: Style this error page when implementing in your project */}
      <h2>Something went wrong!</h2>
      <p>{error.message || 'An unexpected error occurred'}</p>
      <button onClick={() => reset()}>
        Try again
      </button>
    </div>
  );
}
</document_content>
</document>
<document index="27">
<source>apps/webapp/src/app/globals.css</source>
<document_content>
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}

</document_content>
</document>
<document index="28">
<source>apps/webapp/src/app/instruments/page.tsx</source>
<document_content>
import { createClient } from '@/utils/supabase/server';

export default async function Instruments() {
  const supabase = await createClient();
  const { data: instruments } = await supabase.from("instruments").select();

  return <pre>{JSON.stringify(instruments, null, 2)}</pre>
}
</document_content>
</document>
<document index="29">
<source>apps/webapp/src/app/layout.tsx</source>
<document_content>
import type { Metadata } from "next";
import "./globals.css";
import Header from "@/components/Header";
import Footer from "@/components/Footer";

const fontVariables = "font-sans";

export const metadata: Metadata = {
    title: "Ultiplate - Ultimate Boilerplate",
    description: "AI-native template for any project with deployment ready setup",
};

export default function RootLayout({
    children,
}: Readonly<{
    children: React.ReactNode;
}>) {
    return (
        <html lang="en">
            <body className={`${fontVariables} antialiased`}>
                <Header />
                <main className="min-h-screen">
                    {children}
                </main>
                <Footer />
            </body>
        </html>
    );
}

</document_content>
</document>
<document index="30">
<source>apps/webapp/src/app/login/actions.ts</source>
<document_content>
'use server'

import { revalidatePath } from 'next/cache'
import { redirect } from 'next/navigation'

import { createClient } from '@/utils/supabase/server'

export async function login(formData: FormData) {
  const supabase = await createClient()

  // type-casting here for convenience
  // in practice, you should validate your inputs
  const data = {
    email: formData.get('email') as string,
    password: formData.get('password') as string,
  }

  const { error } = await supabase.auth.signInWithPassword(data)

  if (error) {
    redirect('/error')
  }

  revalidatePath('/', 'layout')
  redirect('/')
}

export async function signup(formData: FormData) {
  const supabase = await createClient()

  // type-casting here for convenience
  // in practice, you should validate your inputs
  const data = {
    email: formData.get('email') as string,
    password: formData.get('password') as string,
  }

  const { error } = await supabase.auth.signUp(data)

  if (error) {
    redirect('/error')
  }

  revalidatePath('/', 'layout')
  redirect('/')
}
</document_content>
</document>
<document index="31">
<source>apps/webapp/src/app/login/page.tsx</source>
<document_content>
import { login, signup } from './actions'

export default function LoginPage() {
  return (
    <form>
      <label htmlFor="email">Email:</label>
      <input id="email" name="email" type="email" required />
      <label htmlFor="password">Password:</label>
      <input id="password" name="password" type="password" required />
      <button formAction={login}>Log in</button>
      <button formAction={signup}>Sign up</button>
    </form>
  )
}
</document_content>
</document>
<document index="32">
<source>apps/webapp/src/app/not-found.tsx</source>
<document_content>
import Link from 'next/link';

export default function NotFound() {
  return (
    <div>
      {/* TODO: Style this 404 page when implementing in your project */}
      <h2>Not Found</h2>
      <p>Could not find requested resource</p>
      <Link href="/">Return Home</Link>
    </div>
  );
}
</document_content>
</document>
<document index="33">
<source>apps/webapp/src/app/page.tsx</source>
<document_content>
import Hero from "@/components/Hero";
import FeaturesGrid from "@/components/FeaturesGrid";
import Testimonials1 from "@/components/Testimonials1";
import Pricing from "@/components/Pricing";
//import FAQ from "@/components/FAQ";
//import CTA from "@/components/CTA";

export default function Home() {
  return (
    <div>
      <Hero />
      <FeaturesGrid />
      <Testimonials1 />
      <Pricing />
    </div>
  );
}

</document_content>
</document>
<document index="34">
<source>apps/webapp/src/app/privacy-policy/page.tsx</source>
<document_content>

</document_content>
</document>
<document index="35">
<source>apps/webapp/src/app/tos/page.tsx</source>
<document_content>

</document_content>
</document>
<document index="36">
<source>apps/webapp/src/components/FeaturesGrid.tsx</source>
<document_content>
import { getLocale } from "@/libs/locales";

export default function FeaturesGrid() {
  const { common } = getLocale('en');

  return (
    <section>
      {/* TODO: Style this features grid when implementing in your project */}
      <div>
        <h2>{common.features.title}</h2>
        <div>
          {common.features.items.map((feature, index) => (
            <div key={index}>
              <h3>{feature.title}</h3>
              <p>{feature.description}</p>
            </div>
          ))}
        </div>
      </div>
    </section>
  );
}
</document_content>
</document>
<document index="37">
<source>apps/webapp/src/components/Footer.tsx</source>
<document_content>
import Link from "next/link";
import { getLocale } from "@/libs/locales";

export default function Footer() {
  const { common } = getLocale('en');

  return (
    <footer>
      {/* TODO: Style this footer when implementing in your project */}
      <div>
        <div>
          <div>
            <h3>{common.footer.brand}</h3>
            <p>{common.footer.description}</p>
          </div>
          <div>
            <h4>{common.footer.legal.title}</h4>
            <ul>
              <li><Link href="/privacy-policy">{common.footer.legal.privacyPolicy}</Link></li>
              <li><Link href="/tos">{common.footer.legal.termsOfService}</Link></li>
            </ul>
          </div>
          <div>
            <h4>{common.footer.company.title}</h4>
            <ul>
              <li><Link href="/blog">{common.footer.company.blog}</Link></li>
              <li><Link href="/dashboard">{common.footer.company.dashboard}</Link></li>
            </ul>
          </div>
        </div>
        <div>
          <p>{common.footer.copyright}</p>
        </div>
      </div>
    </footer>
  );
}
</document_content>
</document>
<document index="38">
<source>apps/webapp/src/components/Header.tsx</source>
<document_content>
import Link from "next/link";
import { getLocale } from "@/libs/locales";

export default function Header() {
  const { common } = getLocale('en');

  return (
    <header>
      {/* TODO: Style this header when implementing in your project */}
      <div>
        <div>
          <div>
            <Link href="/">{common.header.brand}</Link>
          </div>
          <nav>
            <Link href="/">{common.header.nav.home}</Link>
            <Link href="/dashboard">{common.header.nav.dashboard}</Link>
            <Link href="/blog">{common.header.nav.blog}</Link>
          </nav>
          <div>
            <Link href="/login">{common.header.actions.signIn}</Link>
          </div>
        </div>
      </div>
    </header>
  );
}

</document_content>
</document>
<document index="39">
<source>apps/webapp/src/components/Hero.tsx</source>
<document_content>
import Link from "next/link";
import { getLocale } from "@/libs/locales";

export default function Hero() {
  const { common } = getLocale('en');

  return (
    <section>
      {/* TODO: Style this hero section when implementing in your project */}
      <div>
        <h1>{common.hero.title}</h1>
        <p>{common.hero.description}</p>
        <div>
          <Link href="/dashboard">
            <button>{common.hero.actions.getStarted}</button>
          </Link>
          <Link href="/blog">
            <button>{common.hero.actions.learnMore}</button>
          </Link>
        </div>
      </div>
    </section>
  );
}
</document_content>
</document>
<document index="40">
<source>apps/webapp/src/components/Pricing.tsx</source>
<document_content>
export default function Pricing() {
  const plans = [
    {
      name: "Open Source",
      price: "Free",
      features: [
        "All boilerplate code",
        "Docker configurations",
        "Basic ML setup",
        "Community support"
      ]
    },
    {
      name: "Pro",
      price: "$49/month",
      features: [
        "Everything in Open Source",
        "Advanced configurations",
        "Priority support",
        "Custom integrations"
      ]
    }
  ];

  return (
    <section>
      {/* TODO: Style this pricing section when implementing in your project */}
      <div>
        <h2>Pricing</h2>
        <div>
          {plans.map((plan, index) => (
            <div key={index}>
              <h3>{plan.name}</h3>
              <p>{plan.price}</p>
              <ul>
                {plan.features.map((feature, featureIndex) => (
                  <li key={featureIndex}>{feature}</li>
                ))}
              </ul>
              <button>Choose Plan</button>
            </div>
          ))}
        </div>
      </div>
    </section>
  );
}
</document_content>
</document>
<document index="41">
<source>apps/webapp/src/components/Testimonials1.tsx</source>
<document_content>
import { getLocale } from "@/libs/locales";

export default function Testimonials1() {
  const { common } = getLocale('en');

  return (
    <section>
      {/* TODO: Style this testimonials section when implementing in your project */}
      <div>
        <h2>{common.testimonials.title}</h2>
        <div>
          {common.testimonials.items.map((testimonial, index) => (
            <div key={index}>
              <p>"{testimonial.content}"</p>
              <div>
                <p>{testimonial.name}</p>
                <p>{testimonial.role}</p>
              </div>
            </div>
          ))}
        </div>
      </div>
    </section>
  );
}
</document_content>
</document>
<document index="42">
<source>apps/webapp/src/libs/locales.ts</source>
<document_content>
import commonEn from '@/locales/en/common.json';

// TODO: Add more languages as needed
const locales = {
  en: {
    common: commonEn
  }
};

export function getLocale(locale: string = 'en') {
  return locales[locale as keyof typeof locales] || locales.en;
}

export function t(key: string, locale: string = 'en') {
  const translations = getLocale(locale);
  const keys = key.split('.');

  let value: any = translations;
  for (const k of keys) {
    value = value?.[k];
  }

  return value || key;
}
</document_content>
</document>
<document index="43">
<source>apps/webapp/src/locales/en/common.json</source>
<document_content>
{
  "header": {
    "brand": "UltiPlate",
    "nav": {
      "home": "Home",
      "dashboard": "Dashboard",
      "blog": "Blog"
    },
    "actions": {
      "signIn": "Sign In"
    }
  },
  "footer": {
    "brand": "UltiPlate",
    "description": "Ultimate boilerplate for any project",
    "legal": {
      "title": "Legal",
      "privacyPolicy": "Privacy Policy",
      "termsOfService": "Terms of Service"
    },
    "company": {
      "title": "Company",
      "blog": "Blog",
      "dashboard": "Dashboard"
    },
    "copyright": "Â© 2024 UltiPlate. All rights reserved."
  },
  "hero": {
    "title": "Welcome to UltiPlate",
    "description": "The ultimate boilerplate for any project - from web apps to ML projects, all deployable with Docker.",
    "actions": {
      "getStarted": "Get Started",
      "learnMore": "Learn More"
    }
  },
  "features": {
    "title": "Features",
    "items": [
      {
        "title": "Docker Ready",
        "description": "Everything containerized and ready to deploy"
      },
      {
        "title": "ML Support",
        "description": "Built-in machine learning project structure"
      },
      {
        "title": "Multiple Backends",
        "description": "FastAPI, Flask, and more backend options"
      },
      {
        "title": "Centralized Logging",
        "description": "Loki-based logging across all services"
      },
      {
        "title": "Database Ready",
        "description": "Redis, MinIO, and database integrations"
      },
      {
        "title": "Web Apps",
        "description": "Next.js and Streamlit app templates"
      }
    ]
  },
  "testimonials": {
    "title": "What People Say",
    "items": [
      {
        "name": "Alex Developer",
        "role": "Full Stack Developer",
        "content": "UltiPlate saved me weeks of setup time. Everything just works out of the box."
      },
      {
        "name": "Sarah ML Engineer",
        "role": "ML Engineer",
        "content": "The ML project structure is perfect. From notebooks to production in minutes."
      },
      {
        "name": "Mike DevOps",
        "role": "DevOps Engineer",
        "content": "Docker integration is seamless. Deploy anywhere with confidence."
      }
    ]
  }
}
</document_content>
</document>
<document index="44">
<source>apps/webapp/src/utils/supabase/client.ts</source>
<document_content>
import { createBrowserClient } from '@supabase/ssr'

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY!
  )
}
</document_content>
</document>
<document index="45">
<source>apps/webapp/src/utils/supabase/middleware.ts</source>
<document_content>
import { createServerClient } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'

export async function updateSession(request: NextRequest) {
  let supabaseResponse = NextResponse.next({
    request,
  })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY!,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll()
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) => request.cookies.set(name, value))
          supabaseResponse = NextResponse.next({
            request,
          })
          cookiesToSet.forEach(({ name, value, options }) =>
            supabaseResponse.cookies.set(name, value, options)
          )
        },
      },
    }
  )

  // Do not run code between createServerClient and
  // supabase.auth.getUser(). A simple mistake could make it very hard to debug
  // issues with users being randomly logged out.

  // IMPORTANT: DO NOT REMOVE auth.getUser()

  const {
    data: { user },
  } = await supabase.auth.getUser()

  if (
    !user &&
    !request.nextUrl.pathname.startsWith('/login') &&
    !request.nextUrl.pathname.startsWith('/auth') &&
    !request.nextUrl.pathname.startsWith('/error')
  ) {
    // no user, potentially respond by redirecting the user to the login page
    const url = request.nextUrl.clone()
    url.pathname = '/login'
    return NextResponse.redirect(url)
  }

  // IMPORTANT: You *must* return the supabaseResponse object as it is.
  // If you're creating a new response object with NextResponse.next() make sure to:
  // 1. Pass the request in it, like so:
  //    const myNewResponse = NextResponse.next({ request })
  // 2. Copy over the cookies, like so:
  //    myNewResponse.cookies.setAll(supabaseResponse.cookies.getAll())
  // 3. Change the myNewResponse object to fit your needs, but avoid changing
  //    the cookies!
  // 4. Finally:
  //    return myNewResponse
  // If this is not done, you may be causing the browser and server to go out
  // of sync and terminate the user's session prematurely!

  return supabaseResponse
}
</document_content>
</document>
<document index="46">
<source>apps/webapp/src/utils/supabase/server.ts</source>
<document_content>
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'

export async function createClient() {
  const cookieStore = await cookies()

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll()
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            )
          } catch {
            // The `setAll` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        },
      },
    }
  )
}
</document_content>
</document>
<document index="47">
<source>apps/webapp/tsconfig.json</source>
<document_content>
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}

</document_content>
</document>
<document index="48">
<source>apps/webapp-minimal/app.py</source>
<document_content>
import streamlit as st

</document_content>
</document>
<document index="49">
<source>apps/worker/requirements.txt</source>
<document_content>
requests
streamlit
fastapi
flask
tqdm
uvicorn
torch

</document_content>
</document>
<document index="50">
<source>apps/worker/worker.py</source>
<document_content>
import os
import time
from celery import Celery

# Redis connection
redis_url = os.getenv("REDIS_URL", "redis://localhost:6379")
app = Celery('worker', broker=redis_url, backend=redis_url)

@app.task
def simple_task(message):
    """A simple task that processes a message and returns a result"""
    time.sleep(2)  # Simulate some work
    return f"Processed: {message}"

@app.task
def add_numbers(x, y):
    """Simple math task"""
    return x + y

if __name__ == '__main__':
    app.start()
</document_content>
</document>
<document index="51">
<source>docker/ml.Dockerfile</source>
<document_content>
FROM python:3.12-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements and install Python dependencies
COPY ml/requirements.txt ./
RUN pip install --no-cache-dir -r requirements.txt

# Copy ML code
COPY ml/ ./
COPY src/ ./src/

# Create models directory
RUN mkdir -p /app/models/weights

# Health check
HEALTHCHECK --interval=30s --timeout=30s --start-period=60s --retries=3 \
    CMD python -c "import requests; requests.get('http://localhost:8000/health').raise_for_status()" || exit 1

EXPOSE 8000

# Create non-root user
RUN useradd --create-home --shell /bin/bash app
RUN chown -R app:app /app
USER app
CMD ["uvicorn", "inference:app", "--host", "0.0.0.0", "--port", "8000"]
</document_content>
</document>
<document index="52">
<source>docker/worker.Dockerfile</source>
<document_content>
FROM python:3.12-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements and install Python dependencies
COPY requirements.txt ./
RUN pip install --no-cache-dir -r requirements.txt
RUN pip install --no-cache-dir redis celery

# Copy worker code
RUN mkdir -p ./worker/
COPY apps/worker/ ./worker/
COPY src/ ./src/

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=30s --retries=3 \
    CMD python -c "import redis; r=redis.from_url('redis://redis:6379'); r.ping()" || exit 1


# Create non-root user
RUN useradd --create-home --shell /bin/bash app
RUN chown -R app:app /app
USER app
CMD ["celery", "-A", "worker.worker:app", "worker", "--loglevel=info"]
</document_content>
</document>
<document index="53">
<source>docker-compose.yml</source>
<document_content>
services:
  redis:
    container_name: "${NAME}-redis"
    image: redis:7-alpine
    ports:
      - "${REDIS_PORT}:6379"
    volumes:
      - redis_data:/data
    restart: unless-stopped

  ml-inference:
    container_name: "${NAME}-mlinfer"
    build:
      context: ./
      dockerfile: ./docker/ml.Dockerfile
    ports:
      - "8200:8000"
    environment:
      - ML_LATEST_WEIGHTS_PATH=/app/models/weights
      - PYTHONPATH=/app
    volumes:
      - ./ml/models:/app/models
      - ./.env:/app/.env
    depends_on:
      - redis
    restart: unless-stopped

  worker:
    container_name: "${NAME}-worker"
    build:
      context: ./
      dockerfile: ./docker/worker.Dockerfile
    environment:
      - REDIS_URL=redis://redis:6379
      - PYTHONPATH=/app
    volumes:
      - ./.env:/app/.env
    depends_on:
      - redis
      - ml-inference
    restart: unless-stopped

  minio:
    image: minio/minio:latest
    container_name: "${NAME}-minio"
    profiles: ["minio"]
    ports:
      - "9900:9000"   # API endpoint
      - "9901:9001"   # Web console
    environment:
      MINIO_ROOT_USER: minioadmin
      MINIO_ROOT_PASSWORD: minioadmin
    volumes:
      - minio_data:/data
    command: server /data --console-address ":9001"
    restart: unless-stopped

  create-bucket:
    image: minio/mc
    container_name: "${NAME}-create-bucket"
    profiles: ["minio"]
    depends_on:
      - minio
    entrypoint: >
      /bin/sh -c "
      sleep 5;
      mc alias set myminio http://minio:9000 minioadmin minioadmin;
      mc mb myminio/dapper --ignore-existing;
      exit 0;
      "

  tensorboard:
    image: tensorflow/tensorflow:latest
    container_name: "${NAME}-tensorboard"
    profiles: ["tensorboard"]
    ports:
      - "6006:6006"
    volumes:
      - ./ml/tensorboard:/logs
    command: tensorboard --logdir=/logs --host=0.0.0.0 --port=6006
    restart: unless-stopped

  # Logging Infrastructure - Minimal Setup
  loki:
    image: grafana/loki:2.9.0
    container_name: "${NAME}-loki"
    profiles: ["logging"]
    ports:
      - "${LOKI_PORT}:3100"
    volumes:
      - loki_data:/loki
    restart: unless-stopped

  grafana:
    image: grafana/grafana:10.2.0
    container_name: "${NAME}-grafana"
    profiles: ["logging"]
    ports:
      - "${GRAFANA_PORT}:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - grafana_data:/var/lib/grafana
    restart: unless-stopped

  # Database Services
  postgres:
    image: postgres:15-alpine
    container_name: "${NAME}-postgres"
    profiles: ["database", "postgres"]
    ports:
      - "${POSTGRES_PORT:-5432}:5432"
    environment:
      POSTGRES_DB: ${POSTGRES_DB:-app}
      POSTGRES_USER: ${POSTGRES_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-postgres}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./database/init.sql:/docker-entrypoint-initdb.d/init.sql:ro
    restart: unless-stopped

  mongodb:
    image: mongo:7-jammy
    container_name: "${NAME}-mongodb"
    profiles: ["database", "mongodb"]
    ports:
      - "${MONGO_PORT:-27017}:27017"
    environment:
      MONGO_INITDB_ROOT_USERNAME: ${MONGO_USER:-admin}
      MONGO_INITDB_ROOT_PASSWORD: ${MONGO_PASSWORD:-admin123}
      MONGO_INITDB_DATABASE: ${MONGO_DB:-app}
    volumes:
      - mongodb_data:/data/db
    restart: unless-stopped

volumes:
  redis_data:
  minio_data:
  loki_data:
  grafana_data:
  postgres_data:
  mongodb_data:

</document_content>
</document>
<document index="54">
<source>ml/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="55">
<source>ml/data/README.md</source>
<document_content>
# Data

Some thoughts on processing data: In a lot of cases you will get data not in an s3 bucket or anything glamarous and for doing anything in terms of modelling you need the data locally but then when you maybe have a 1TB dataset you want 10GB locally and then you upload to a GPU rich server and there you will want all of teh data. How can you managed this data well? What are best practices?

Huggingface lets you upload up to 300 gigs of data into a dataset.

</document_content>
</document>
<document index="56">
<source>ml/data/etl.py</source>
<document_content>

</document_content>
</document>
<document index="57">
<source>ml/inference.py</source>
<document_content>
import os
import torch
import torch.nn as nn
from fastapi import FastAPI
from pydantic import BaseModel

# TODO: Import model when ready
from models import * # TODO: SPECIFY

class InputData(BaseModel):
    pass


weights_path = os.getenv("ML_LATEST_WEIGHTS_PATH")
if weights_path is None:
    raise RuntimeError("ML_LATEST_WEIGHTS_PATH not set")


# FastAPI app
app = FastAPI(title="ML Inference API", version="1.0.0")

@app.get("/health")
def health_check():
    return {"status": "healthy", "service": "ml-inference"}

@app.post("/predict")
def predict(data: InputData):

    #TODO: x = torch.tensor([data.features], dtype=torch.float32)

    with torch.no_grad():

        #TODO: y = model(x)

        y=torch.tensor(0)
    return {"prediction": y.tolist()}

</document_content>
</document>
<document index="58">
<source>ml/models/arch.py</source>
<document_content>
import torch
import torch.nn as nn

class Model(nn.Module):
    # TODO: Define
    pass

</document_content>
</document>
<document index="59">
<source>ml/models/train.py</source>
<document_content>
import torch
import torch.nn as nn
from torch.utils.tensorboard import SummaryWriter
from alveslib import get_logger

logger = get_logger("ml-trainloop")
logger.info("initiated loop for training")

class Trainer:
    def __init__(self, model, train_loader, log_dir="../tensorboard"):
        self.model = model
        self.train_loader = train_loader
        self.optimizer = torch.optim.Adam(model.parameters())
        self.criterion = nn.CrossEntropyLoss()
        self.writer = SummaryWriter(log_dir)
        self.step = 0

    def train_epoch(self):
        self.model.train()
        for batch_idx, (data, target) in enumerate(self.train_loader):
            self.optimizer.zero_grad()
            output = self.model(data)
            loss = self.criterion(output, target)
            loss.backward()
            self.optimizer.step()

            if batch_idx % 100 == 0:
                self.writer.add_scalar('Loss/Train', loss.item(), self.step)
                self.step += 1

    def train(self, epochs):
        for epoch in range(epochs):
            self.train_epoch()
        self.writer.close()

</document_content>
</document>
<document index="60">
<source>ml/requirements.txt</source>
<document_content>
requests
streamlit
fastapi
flask
tqdm
uvicorn
torch

</document_content>
</document>
<document index="61">
<source>requirements.txt</source>
<document_content>
requests
streamlit
fastapi
flask
tqdm
uvicorn
torch
seleniumbase
pyspark
flask-cors
python-logging-loki
python-dotenv
tensorboard

</document_content>
</document>
<document index="62">
<source>setup.py</source>
<document_content>
from setuptools import setup, find_packages

setup(
    name="ultiplate",
    version="0.1.0",
    packages=find_packages(),
    install_requires=[
        "python-logging-loki",
        "python-dotenv",
    ],
)
</document_content>
</document>
<document index="63">
<source>src/__init__.py</source>
<document_content>

</document_content>
</document>
<document index="64">
<source>src/main.py</source>
<document_content>
from logger import get_logger

def main():
    logger = get_logger("example_service", level="DEBUG")

    logger.info("Service starting up")
    logger.debug("This is debug information")
    logger.warning("This is a warning")

    try:
        # Simulate some work
        result = 10 / 2
        logger.info(f"Calculation result: {result}")
    except Exception as e:
        logger.error(f"Error occurred: {e}", exc_info=True)

    logger.info("Service shutting down")

if __name__ == "__main__":
    main()

</document_content>
</document>
</documents>
